# -*- coding: utf-8 -*-
"""Shakir-Exercise1-Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Dfs9teINdIEFgm6GDCKz3OE3_BuB9uUd

##**1. Introduction to Python - Exercise 1**

####**Global Library Initiation**
"""

import math

"""####**1.1 Elementary Data Types**"""

#Code chunk is introducing the different data types in Python. Python automatically assigns data type based on the argument initiated.
x = 4              # integer
print(x, type(x))

y = True           # boolean (True, False)
print(y, type(y))

z = 3.7            # floating point
print(z, type(z))

s = "This is a string"    # string
print(s, type(s))

#Code chunk is to initiate, manipulate and print the varibles in the form of a variable. Additional- Used round functions to clean up the floating point decimals.
x = 4            # integer; x value is initiated as 4
x1 = x + 4       # addition; x1 value is initiated as 8
x2 = x * 3       # multiplication; x2 value is initiated as 12
x += 2           # equivalent to x = x + 2; x value is incremented to 6
x3 = x           #x3 value is initiated as 6, value copied from latest iteration of 'x'
x *= 3           # equivalent to x = x * 3; x value is multiplied and new value is 6*3=18
x4 = x           # x4 is iniated as 18, new value of x
x5 = x % 4       # modulo (remainder) operator; x5 is iniated as remainder of 18/4, which is 2. x value remains unchanged.

z = 3.7          # floating point number
z1 = round (z - 2,3)       # subtraction
z2 = round(z / 3,3)       # division
z3 = round(z // 3,3)      # integer division
z4 = round(z ** 2,3)      # square of z
z5 = round(z4 ** 0.5,3)   # square root
z6 = round(pow(z,2),3)    # equivalent to square of z
z7 = round(z)    # rounding z to its nearest integer
z8 = int(z)      # type casting float to int

print(x,x1,x2,x3,x4,x5)
print(z,z1,z2,z3,z4)
print(z5,z6,z7,z8)

#The math module offers the following functions for integers and floating point numbers.

x = 4
print(math.sqrt(x))      # sqrt(4) = 2
print(math.pow(x,2))     # 4**2 = 16
print(math.exp(x))       # exp(4) = 54.6
print(math.log(x,2))     # log based 2  (default is natural logarithm)
print(math.fabs(-4))     # absolute value
print(math.factorial(x)) # 4! = 4 x 3 x 2 x 1 = 24

z = 0.2
print(math.ceil(z))      # ceiling function
print(math.floor(z))     # floor function
print(math.trunc(z))     # truncate function

z = 3*math.pi            # math.pi = 3.141592653589793
print(math.sin(z))       # sine function
print(math.tanh(z))      # arctan function

x = math.nan             # not a number
print(math.isnan(x))

x = math.inf             # infinity
print(math.isinf(x))

#Code chunk defining the logical operations done and manipulation on boolean data set.
y1 = True
y2 = False

print(y1 and y2)       # logical AND
print(y1 or y2)        # logical OR
print(y1 and not y2)   # logical NOT

#Code chunk is to manipulate strings
s1 = "This"

print(s1[1:])                    # print last three characters
print(len(s1))                               # get the string length
print("Length of string is " + str(len(s1))) # type casting int to str
print(s1.upper())                            # convert to upper case
print(s1.lower())                            # convert to lower case

s2 = "This is a string"
words = s2.split(' ')             # split the string into words
print(words[0])                   # To return the individual words split from the split function, starting with 0 as first word
print(s2.replace('a','another'))  # replace "a" with "another"
print(s2.replace('is','at'))      # replace "is" with "at"
print(s2.find("a"))               # find the position of "a" in s2
print(s1 in s2)                   # check if s1 is a substring of s2

print(s1 == 'This')               # equality comparison
print(s1 < 'That')                # inequality comparison
print(s2 + " too")                # string concatenation
print((s1 + " ")* 3)              # replicate the string 3 times

"""####**1.2 Compound Data Types**"""

#Code chunk is to manipulate number arrays (lists) and perform basic operations on them
intlist = [1, 3, 5, 7, 9]
print(type(intlist))             #Prints the dataset type of 'intlist'
print(intlist)                   # Printing te list array as is
intlist2 = list(range(0,10,2))   # range[startvalue, endvalue, stepsize]
print(intlist2)

print(intlist[2])                # get the third element of the list
print(intlist[:2])               # get the first two elements
print(intlist[2:])               # get the last three elements of the list
print(len(intlist))              # get the number of elements in the list
print(sum(intlist))              # sums up elements of the list

intlist.append(11)               # insert 11 to end of the list
print(intlist)
print(intlist.pop())             # remove last element of the list
print(intlist)
print(intlist + [11,13,15])      # concatenate two lists
print(intlist * 3)               # replicate the list
intlist.insert(2,4)              # insert item 4 at index 2
print(intlist)
intlist.sort(reverse=True)       # sort elements in descending order
print(intlist)

#Code chunk is to define a string array, and perform manipulations on the dataset
mylist = ['this', 'is', 'a', 'list']
print(mylist)
print(type(mylist))

print("list" in mylist)          # check whether "list" is in mylist
print(mylist[2])                 # show the 3rd element of the list
print(mylist[:2])                # show the first two elements of the list
print(mylist[2:])                # show the last two elements of the list
mylist.append("too")             # insert element to end of the list

separator = " "                  #Define separator as a space. This is not necessary to get the same output
print(separator.join(mylist))    # merge all elements of the list into a string

mylist.remove("is")              # remove element from list
print(mylist)

#Code chunk shows how to create and manipulate a dictionary object
abbrev = {}
abbrev['MI'] = "Michigan"
abbrev['MN'] = "Minnesota"
abbrev['TX'] = "Texas"
abbrev['CA'] = "California"

print(abbrev)
print(abbrev.keys())            # get the keys of the dictionary
print(abbrev.values())          # get the values of the dictionary
print(len(abbrev))              # get number of key-value pairs

print(abbrev.get('MI'))
print("FL" in abbrev)
print("CA" in abbrev)

keys = ['apples', 'oranges', 'bananas', 'cherries']
values = [3, 4, 2, 10]
fruits = dict(zip(keys, values))
print(fruits)
print(sorted(fruits))     # sort keys of dictionary

from operator import itemgetter
print(sorted(fruits.items(), key=itemgetter(0)))    # sort by key of dictionary
print(sorted(fruits.items(), key=itemgetter(1)))    # sort by value of dictionary

# Code chunk shows how to create and manipulate a tuple object
MItuple = ('MI', 'Michigan', 'Lansing')
CAtuple = ('CA', 'California', 'Sacramento')
TXtuple = ('TX', 'Texas', 'Austin')

print(MItuple)
print(MItuple[1:])

states = [MItuple, CAtuple, TXtuple]    # this will create a list of tuples
print(states)
print(states[2])
print(states[2][:])
print(states[2][1:])

states.sort(key=lambda state: state[2])  # sort the states by their capital cities
print(states)

"""####**1.3 Control Flow Statements**"""

#The if, for, and while statements are control flow statements in Python, much like in other programming languages. Below are some examples of how to utilize these statements.
#using if-else statement

x = 10

if x % 2 == 0:
    print("x =", x, "is even")
else:
    print("x =", x, "is odd")

if x > 0:
    print("x =", x, "is positive")
elif x < 0:
    print("x =", x, "is negative")
else:
    print("x =", x, "is neither positive nor negative")

# using for loop with a list

mylist = ['this', 'is', 'a', 'list']
for word in mylist:
    print(word.replace("is", "at"))

mylist2 = [len(word) for word in mylist]   # number of characters in each word
print(mylist2)

# using for loop with list of tuples

states = [('MI', 'Michigan', 'Lansing'),('CA', 'California', 'Sacramento'),
          ('TX', 'Texas', 'Austin')]

sorted_capitals = [state[2] for state in states]
sorted_capitals.sort()
print(sorted_capitals)

# using for loop with dictionary

fruits = {'apples': 3, 'oranges': 4, 'bananas': 2, 'cherries': 10}
fruitnames = [k for (k,v) in fruits.items()]
print(fruitnames)

# using while loop

mylist = list(range(-10,10))
print(mylist)

i = 0
while (mylist[i] < 0):
    i = i + 1

print("First non-negative number:", mylist[i])

"""####**1.4 User-Defined Functions**"""

#The lambda keyword is used to define unnamed functions, as seen in the preceding example for sorting a list of tuples.

myfunc = lambda x: 3*x**2 - 2*x + 3      # example of an unnamed quadratic function

print(myfunc(2))

#The lambda keyword is used to define unnamed functions, as seen in the preceding example for sorting a list of tuples.

import math

# The following function will discard missing values from a list
def discard(inlist, sortFlag=False):    # default value for sortFlag is False
    outlist = []
    for item in inlist:
        if not math.isnan(item):
            outlist.append(item)

    if sortFlag:
        outlist.sort()
    return outlist

mylist = [12, math.nan, 23, -11, 45, math.nan, 71]

print(discard(mylist,True))

"""####**1.5 File I/O**"""

#Data from a list or other objects can be read from and written to a file.

states = [('MI', 'Michigan', 'Lansing'),('CA', 'California', 'Sacramento'),
          ('TX', 'Texas', 'Austin'), ('MN', 'Minnesota', 'St Paul')]

with open('states.txt', 'w') as f:
    f.write('\n'.join('%s,%s,%s' % state for state in states))

with open('states.txt', 'r') as f:
    for line in f:
        fields = line.split(sep=',')    # split each line into its respective fields
        print('State=',fields[1],'(',fields[0],')','Capital:', fields[2])

"""##**2. Introduction to Numpy and Pandas**

###**Global Library Initiation**
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
from pandas import Series
from pandas import DataFrame
# %matplotlib inline

"""###**2.1 Introduction to Numpy**

####**2.1.1 Creating ndarray**
"""

#As seen in the examples below, an ndarray may be produced from a list or a tuple object. The list objects and tuples can be used to build a one-dimensional or multi-dimensional array.

import numpy as np

oneDim = np.array([1.0,2,3,4,5])   # a 1-dimensional array (vector)
print(oneDim)
print("#Dimensions =", oneDim.ndim)
print("Dimension =", oneDim.shape)
print("Size =", oneDim.size)
print("Array type =", oneDim.dtype, '\n')

twoDim = np.array([[1,2],[3,4],[5,6],[7,8]])  # a two-dimensional array (matrix)
print(twoDim)
print("#Dimensions =", twoDim.ndim)
print("Dimension =", twoDim.shape)
print("Size =", twoDim.size)
print("Array type =", twoDim.dtype, '\n')

arrFromTuple = np.array([(1,'a',3.0),(2,'b',3.5)])  # create ndarray from tuple
print(arrFromTuple)
print("#Dimensions =", arrFromTuple.ndim)
print("Dimension =", arrFromTuple.shape)
print("Size =", arrFromTuple.size)

#Additionally, numpy has built-in routines that may be used to construct ndarrays.

print('Array of random numbers from a uniform distribution')
print(np.random.rand(5))      # random numbers from a uniform distribution between [0,1]

print('\nArray of random numbers from a normal distribution')
print(np.random.randn(5))     # random numbers from a normal distribution

print('\nArray of integers between -10 and 10, with step size of 2')
print(np.arange(-10,10,2))    # similar to range, but returns ndarray instead of list

print('\n2-dimensional array of integers from 0 to 11')
print(np.arange(12).reshape(3,4))  # reshape to a matrix

print('\nArray of values between 0 and 1, split into 10 equally spaced values')
print(np.linspace(0,1,10))    # split interval [0,1] into 10 equally separated values

print('\nArray of values from 10^-3 to 10^3')
print(np.logspace(-3,3,7))    # create ndarray with values from 10^-3 to 10^3

#Printing multi dimensional array

print('A 2 x 3 matrix of zeros')
print(np.zeros((2,3)))        # a matrix of zeros

print('\nA 3 x 2 matrix of ones')
print(np.ones((3,2)))         # a matrix of ones

print('\nA 3 x 3 identity matrix')
print(np.eye(3))              # a 3 x 3 identity matrix

"""####**2.1.2 Element-wise Operations**"""

#Array arithmatic operations

x = np.array([1,2,3,4,5])

print('x =', x)
print('x + 1 =', x + 1)      # addition
print('x - 1 =', x - 1)      # subtraction
print('x * 2 =', x * 2)      # multiplication
print('x // 2 =', x // 2)     # integer division
print('x ** 2 =', x ** 2)     # square
print('x % 2 =', x % 2)      # modulo
print('1 / x =', 1 / x)      # division

#Element wise operations on arrays

x = np.array([2,4,6,8,10])
y = np.array([1,2,3,4,5])

print('x =', x)
print('y =', y)
print('x + y =', x + y)      # element-wise addition
print('x - y =', x - y)      # element-wise subtraction
print('x * y =', x * y)      # element-wise multiplication
print('x / y =', x / y)      # element-wise division
print('x // y =', x // y)    # element-wise integer division
print('x ** y =', x ** y)    # element-wise exponentiation

"""####**2.1.3 Indexing and Slicing**"""

#A reference to a numpy array (or a subset of its components) will be sent to another variable in place of duplicating the array's values. The.copy() method must be explicitly called in order to duplicate an ndarray.

x = np.arange(-5,5)
print('Before: x =', x)

y = x[3:5]     # y is a slice, i.e., pointer to a subarray in x
print('        y =', y)
y[:] = 1000    # modifying the value of y will change x
print('After : y =', y)
print('        x =', x, '\n')

z = x[3:5].copy()   # makes a copy of the subarray
print('Before: x =', x)
print('        z =', z)
z[:] = 500          # modifying the value of z will not affect x
print('After : z =', z)
print('        x =', x)

#The distinction between indexing list elements and ndarray elements is demonstrated by the following example.

my2dlist = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]  # a 2-dim list
print('my2dlist =', my2dlist)
print('my2dlist[2] =', my2dlist[2])            # access the third sublist
print('my2dlist[:][2] =', my2dlist[:][2])      # can't access third element of each sublist
# print('my2dlist[:,2] =', my2dlist[:,2])      # invalid way to access sublist, will cause syntax error

my2darr = np.array(my2dlist)
print('\nmy2darr =\n', my2darr)

print('my2darr[2][:] =', my2darr[2][:])      # access the third row
print('my2darr[2,:] =', my2darr[2,:])        # access the third row
print('my2darr[:][2] =', my2darr[:][2])      # access the third row (similar to 2d list)
print('my2darr[:,2] =', my2darr[:,2])        # access the third column
print('my2darr[:2,2:] =\n', my2darr[:2,2:])     # access the first two rows & last two columns

#Numpy indexing with boolean data type

my2darr = np.arange(1,13,1).reshape(3,4)
print('my2darr =\n', my2darr)

divBy3 = my2darr[my2darr % 3 == 0]
print('\nmy2darr[my2darr % 3 == 0] =', divBy3)            # returns all the elements divisible by 3 in an ndarray

divBy3LastRow = my2darr[2:, my2darr[2,:] % 3 == 0]
print('my2darr[2:, my2darr[2,:] % 3 == 0] =', divBy3LastRow)    # returns elements in the last row divisible by 3

my2darr = np.arange(1,13,1).reshape(4,3)
print('my2darr =\n', my2darr)

indices = [2,1,0,3]    # selected row indices
print('indices =', indices, '\n')
print('my2darr[indices,:] =\n', my2darr[indices,:])  # this will shuffle the rows of my2darr

rowIndex = [0,0,1,2,3]     # row index into my2darr
print('\nrowIndex =', rowIndex)
columnIndex = [0,2,0,1,2]  # column index into my2darr
print('columnIndex =', columnIndex, '\n')
print('my2darr[rowIndex,columnIndex] =', my2darr[rowIndex,columnIndex])

"""####**2.1.4 Numpy Arithmetic and Statistical Functions**

"""

#Numerous built-in mathematical functions in Numpy are available to manipulate the components of an ndarray.
#Part 1
y = np.array([-1.4, 0.4, -3.2, 2.5, 3.4])
print('y =', y, '\n')

print('np.abs(y) =', np.abs(y))                # convert to absolute values
print('np.sqrt(abs(y)) =', np.sqrt(abs(y)))    # apply square root to each element
print('np.sign(y) =', np.sign(y))              # get the sign of each element
print('np.exp(y) =', np.exp(y))                # apply exponentiation
print('np.sort(y) =', np.sort(y))              # sort array

#Numerous built-in mathematical functions in Numpy are available to manipulate the components of an ndarray.
#Part 2
x = np.arange(-2,3)
y = np.random.randn(5)
print('x =', x)
print('y =', y, '\n')

print('np.add(x,y) =', np.add(x,y))                # element-wise addition       x + y
print('np.subtract(x,y) =', np.subtract(x,y))      # element-wise subtraction    x - y
print('np.multiply(x,y) =', np.multiply(x,y))      # element-wise multiplication x * y
print('np.divide(x,y) =', np.divide(x,y))          # element-wise division       x / y
print('np.maximum(x,y) =', np.maximum(x,y))        # element-wise maximum        max(x,y)

#Numerous built-in mathematical functions in Numpy are available to manipulate the components of an ndarray.
#Part 3
y = np.array([-3.2, -1.4, 0.4, 2.5, 3.4])
print('y =', y, '\n')

print("Min =", np.min(y))             # min
print("Max =", np.max(y))             # max
print("Average =", np.mean(y))        # mean/average
print("Std deviation =", np.std(y))   # standard deviation
print("Sum =", np.sum(y))             # sum

"""####**2.1.5 Numpy linear algebra**


"""

# Numpy operations using linear algebra operations

X = np.random.randn(2,3)                         # create a 2 x 3 random matrix
print('X =\n', X, '\n')
print('Transpose of X, X.T =\n', X.T, '\n')      # matrix transpose operation X^T

y = np.random.randn(3) # random vector
print('y =', y, '\n')

print('Matrix-vector multiplication')
print('X.dot(y) =\n', X.dot(y), '\n')            # matrix-vector multiplication  X * y

print('Matrix-matrix product')
print('X.dot(X.T) =', X.dot(X.T))        # matrix-matrix multiplication  X * X^T
print('\nX.T.dot(X) =\n', X.T.dot(X))      # matrix-matrix multiplication  X^T * X

# Numpy operations using linear algebra operations

X = np.random.randn(5,3)
print('X =\n', X, '\n')

C = X.T.dot(X)               # C = X^T * X is a square matrix
print('C = X.T.dot(X) =\n', C, '\n')

invC = np.linalg.inv(C)      # inverse of a square matrix
print('Inverse of C = np.linalg.inv(C)\n', invC, '\n')

detC = np.linalg.det(C)      # determinant of a square matrix
print('Determinant of C = np.linalg.det(C) =', detC)

S, U = np.linalg.eig(C)      # eigenvalue S and eigenvector U of a square matrix
print('Eigenvalues of C =\n', S)
print('Eigenvectors of C =\n', U)

"""###**2.2 Introduction to Pandas**

####**2.2.1 Series**
"""

#From a list, a numpy array, or a Python dictionary, a Series object may be made. The majority of numpy functions may be used on the Series object.

s = Series([3.1, 2.4, -1.7, 0.2, -2.9, 4.5])   # creating a series from a list
print('Series, s =\n', s, '\n')

print('s.values =', s.values)     # display values of the Series
print('s.index =', s.index)       # display indices of the Series
print('s.dtype =', s.dtype)       # display the element type of the Series

#Displaying a series defined using numpy array

s2 = Series(np.random.randn(6))   # creating a series from a numpy ndarray
print('Series s2 =\n', s2, '\n')
print('s2.values =', s2.values)   # display values of the Series
print('s2.index =', s2.index)     # display indices of the Series
print('s2.dtype =', s2.dtype)     # display the element type of the Series

#Displaying a series defined using numpy array


s3 = Series([1.2,2.5,-2.2,3.1,-0.8,-3.2],
            index = ['Jan 1','Jan 2','Jan 3','Jan 4','Jan 5','Jan 6'])
print('Series s3 =\n', s3, '\n')
print('s3.values =', s3.values)   # display values of the Series
print('s3.index =', s3.index)     # display indices of the Series
print('s3.dtype =', s3.dtype)     # display the element type of the Series

#Displaying a series made from dictionary object

capitals = {'MI': 'Lansing', 'CA': 'Sacramento', 'TX': 'Austin', 'MN': 'St Paul'}

s4 = Series(capitals)   # creating a series from dictionary object
print('Series s4 =\n', s4, '\n')
print('s4.values =', s4.values)   # display values of the Series
print('s4.index=', s4.index)      # display indices of the Series
print('s4.dtype =', s4.dtype)     # display the element type of the Series

#Code chunk to show the slice operations for the series

s3 = Series([1.2,2.5,-2.2,3.1,-0.8,-3.2],
            index = ['Jan 1','Jan 2','Jan 3','Jan 4','Jan 5','Jan 6',])
print('s3 =\n', s3, '\n')

# Accessing elements of a Series

print('s3[2]=', s3[2])        # display third element of the Series
print('s3[\'Jan 3\']=', s3['Jan 3'])   # indexing element of a Series

print('\ns3[1:3]=')             # display a slice of the Series
print(s3[1:3])
print('\ns3.iloc([1:3])=')      # display a slice of the Series
print(s3.iloc[1:3])

#Introduction of a np.nan as a null function

s3['Jan 7'] = np.nan
print('Series s3 =\n', s3, '\n')

print('Shape of s3 =', s3.shape)   # get the dimension of the Series
print('Size of s3 =', s3.size)     # get the number of elements of the Series
print('Count of s3 =', s3.count()) # get the number of non-null elements of the Series

#A boolean filter can be used to select elements of a Series

print(s3[s3 > 0])   # applying filter to select non-negative elements of the Series

#Scalar operations can be performed on elements of a numeric Series

print('s3 + 4 =\n', s3 + 4, '\n')
print('s3 / 4 =\n', s3 / 4)

#Numpy functions being applied to a pandas series

print('np.log(s3 + 4) =\n', np.log(s3 + 4), '\n')    # applying log function to a numeric Series
print('np.exp(s3 - 4) =\n', np.exp(s3 - 4), '\n')    # applying exponent function to a numeric Series

#Function value.counts is used for tabulating the counts of each discrete value in the Series.

colors = Series(['red', 'blue', 'blue', 'yellow', 'red', 'green', 'blue', np.nan])
print('colors =\n', colors, '\n')

print('colors.value_counts() =\n', colors.value_counts())

"""####**2.2.2 DataFrame**"""

#Dataframe initiation and displaying in tabular format

cars = {'make': ['Ford', 'Honda', 'Toyota', 'Tesla'],
       'model': ['Taurus', 'Accord', 'Camry', 'Model S'],
       'MSRP': [27595, 23570, 23495, 68000]}
carData = DataFrame(cars)            # creating DataFrame from dictionary
carData                              # display the table

#Function to display row and dolumn indices

print('carData.index =', carData.index)         # print the row indices
print('carData.columns =', carData.columns)     # print the column indices

#Updating old table with updated row index and column index is same

carData2 = DataFrame(cars, index = [1,2,3,4])  # change the row index
carData2['year'] = 2018    # add column with same value
carData2['dealership'] = ['Courtesy Ford','Capital Honda','Spartan Toyota','N/A']
carData2                   # display table

#Creating DataFrame from a list of tuples.

tuplelist = [(2011,45.1,32.4),(2012,42.4,34.5),(2013,47.2,39.2),
              (2014,44.2,31.4),(2015,39.9,29.8),(2016,41.5,36.7)]
columnNames = ['year','temp','precip']
weatherData = DataFrame(tuplelist, columns=columnNames)
weatherData

#Creating DataFrame from numpy ndarray

npdata = np.random.randn(5,3)  # create a 5 by 3 random matrix
columnNames = ['x1','x2','x3']
data = DataFrame(npdata, columns=columnNames)
data

# accessing an entire column will return a Series object

print(data['x2'])
print(type(data['x2']))

# accessing an entire row will return a Series object

print('Row 3 of data table:')
print(data.iloc[2])       # returns the 3rd row of DataFrame
print(type(data.iloc[2]))

print('\nRow 3 of car data table:')
print(carData2.iloc[2])   # row contains objects of different types

# accessing a specific element of the DataFrame

print('carData2 =\n', carData2)

print('\ncarData2.iloc[1,2] =', carData2.iloc[1,2])                # retrieving second row, third column
print('carData2.loc[1,\'model\'] =', carData2.loc[1,'model'])    # retrieving second row, column named 'model'

# accessing a slice of the DataFrame

print('\ncarData2.iloc[1:3,1:3]=')
print(carData2.iloc[1:3,1:3])

print('carData2 =\n', carData2, '\n')

print('carData2.shape =', carData2.shape)
print('carData2.size =', carData2.size)

# selection and filtering

print('carData2 =\n', carData2, '\n')

print('carData2[carData2.MSRP > 25000] =')
print(carData2[carData2.MSRP > 25000])

"""####**2.2.3 Arithmetic Operations**"""

#Arithmatic operations on arrays

print(data)

print('\nData transpose operation: data.T')
print(data.T)    # transpose operation

print('\nAddition: data + 4')
print(data + 4)    # addition operation

print('\nMultiplication: data * 10')
print(data * 10)   # multiplication operation

#Arithmatic operations on arrays

print('data =\n', data)

columnNames = ['x1','x2','x3']
data2 = DataFrame(np.random.randn(5,3), columns=columnNames)
print('\ndata2 =')
print(data2)

print('\ndata + data2 = ')
print(data.add(data2))

print('\ndata * data2 = ')
print(data.mul(data2))

#Arithmatic operations on arrays

print(data.abs())    # get the absolute value for each element

print('\nMaximum value per column:')
print(data.max())    # get maximum value for each column

print('\nMinimum value per row:')
print(data.min(axis=1))    # get minimum value for each row

print('\nSum of values per column:')
print(data.sum())    # get sum of values for each column

print('\nAverage value per row:')
print(data.mean(axis=1))    # get average value for each row

print('\nCalculate max - min per column')
f = lambda x: x.max() - x.min()
print(data.apply(f))

print('\nCalculate max - min per row')
f = lambda x: x.max() - x.min()
print(data.apply(f, axis=1))

#value_counts() function being applied to a pandas DataFrame

objects = {'shape': ['circle', 'square', 'square', 'square', 'circle', 'rectangle'],
           'color': ['red', 'red', 'red', 'blue', 'blue', 'blue']}

shapeData = DataFrame(objects)
print('shapeData =\n', shapeData, '\n')

print('shapeData.value_counts() =\n', shapeData.value_counts().sort_values())

"""####**2.2.4 Plotting Series and DataFrame**

"""

#Built in function to plot data stored in series as a lineplot

s3 = Series([1.2,2.5,-2.2,3.1,-0.8,-3.2,1.4],
            index = ['Jan 1','Jan 2','Jan 3','Jan 4','Jan 5','Jan 6','Jan 7'])
s3.plot(kind='line', title='Line plot')

#Built in function to plot data stored in series as a barplot

s3.plot(kind='bar', title='Bar plot')

#Built in function to plot data stored in series as a histogram

s3.plot(kind='hist', title = 'Histogram')

#Built in function to plot data stored in series as a boxplot

tuplelist = [(2011,45.1,32.4),(2012,42.4,34.5),(2013,47.2,39.2),
              (2014,44.2,31.4),(2015,39.9,29.8),(2016,41.5,36.7)]
columnNames = ['year','temp','precip']
weatherData = DataFrame(tuplelist, columns=columnNames)
weatherData[['temp','precip']].plot(kind='box', title='Box plot')

#Built in function to plot data stored in series as a scatterplot

print('weatherData =\n', weatherData)

weatherData.plot(kind='scatter', x='temp', y='precip')